<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI å¼€å‘å·¥å…·é›†</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      color: #4a90e2;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tab {
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      color: #888;
      cursor: pointer;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s;
    }

    .tab:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .tab.active {
      background: #4a90e2;
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .section h2 {
      margin-bottom: 15px;
      color: #4a90e2;
      font-size: 18px;
    }

    .control-panel {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      padding: 10px 20px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover {
      background: #357abd;
    }

    button.success {
      background: #2dcc70;
    }

    button.success:hover {
      background: #27ae60;
    }

    button.danger {
      background: #e74c3c;
    }

    button.danger:hover {
      background: #c0392b;
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .input-group label {
      color: #888;
    }

    .input-group input {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: white;
      width: 100px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    .stat-card .label {
      font-size: 12px;
      color: #888;
      margin-bottom: 5px;
    }

    .stat-card .value {
      font-size: 24px;
      font-weight: bold;
      color: #4a90e2;
    }

    .info-box {
      background: rgba(74, 144, 226, 0.1);
      border-left: 4px solid #4a90e2;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 15px;
    }

    .info-box h3 {
      margin-bottom: 10px;
      font-size: 14px;
    }

    .info-box p {
      font-size: 13px;
      color: #bbb;
      margin-bottom: 5px;
    }

    .progress-bar {
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    .progress-fill {
      height: 100%;
      background: #2dcc70;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: white;
    }

    .log-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }

    .log-entry {
      padding: 5px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .log-entry.success {
      color: #2dcc70;
    }

    .log-entry.error {
      color: #e74c3c;
    }

    .log-entry.warning {
      color: #f39c12;
    }

    .action-stats {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .action-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }

    .action-name {
      font-weight: bold;
    }

    .code-block {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      padding: 15px;
      overflow-x: auto;
      font-family: monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
    }

    .suggestion-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #f39c12;
    }

    .suggestion-item.error {
      border-left-color: #e74c3c;
    }

    .suggestion-item h4 {
      margin-bottom: 5px;
      color: #f39c12;
    }

    .suggestion-item.error h4 {
      color: #e74c3c;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ› ï¸ AI å¼€å‘å·¥å…·é›†</h1>
    <p class="subtitle">å½’å…ƒå¥• AI è°ƒè¯•ã€ä¼˜åŒ–ã€æ•°æ®åˆ†æå·¥å…·</p>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('overview')">ğŸ“Š æ•°æ®æ¦‚è§ˆ</button>
      <button class="tab" onclick="switchTab('simulator')">âš¡ å¿«é€Ÿæ¨¡æ‹Ÿ</button>
      <button class="tab" onclick="switchTab('optimizer')">âš™ï¸ æƒé‡ä¼˜åŒ–</button>
      <button class="tab" onclick="switchTab('raw-data')">ğŸ“„ åŸå§‹æ•°æ®</button>
      <button class="tab" onclick="switchTab('debug')">ğŸ” è°ƒè¯•</button>
    </div>

    <!-- æ•°æ®æ¦‚è§ˆ -->
    <div id="tab-overview" class="tab-content active">
      <div class="section">
        <h2>ğŸ“ˆ æ€»è§ˆç»Ÿè®¡</h2>
        <div class="control-panel" style="margin-bottom: 15px;">
          <button onclick="loadOverview()">ğŸ”„ åˆ·æ–°æ•°æ®</button>
          <button class="danger" onclick="clearAllData()">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ•°æ®</button>
          <button onclick="exportData()">ğŸ“¤ å¯¼å‡ºæ•°æ®</button>
        </div>
        <div id="overview-content">
          <p style="color: #888; text-align: center; padding: 40px;">ç‚¹å‡»"åˆ·æ–°æ•°æ®"åŠ è½½ç»Ÿè®¡...</p>
        </div>
      </div>
    </div>

    <!-- å¿«é€Ÿæ¨¡æ‹Ÿ -->
    <div id="tab-simulator" class="tab-content">
      <div class="section">
        <h2>âš¡ å¿«é€Ÿæ¨¡æ‹Ÿå™¨ï¼ˆä½¿ç”¨ä¸»ç¨‹åºé€»è¾‘ï¼‰</h2>

        <div class="info-box">
          <h3>ğŸ’¡ è¯´æ˜</h3>
          <p>æ­¤æ¨¡æ‹Ÿå™¨ä½¿ç”¨ä¸»ç¨‹åºçš„å®Œæ•´æ¸¸æˆé€»è¾‘ï¼ˆActionResolverã€ActionValueCalculatorç­‰ï¼‰ã€‚</p>
          <p>AI vs AI å¯¹æˆ˜ï¼Œæ•°æ®ä¼šä¿å­˜åˆ° localStorage ä¾›åç»­åˆ†æã€‚</p>
        </div>

        <div class="control-panel" style="margin-bottom: 15px;">
          <div class="input-group">
            <label>æ¨¡æ‹Ÿå±€æ•°:</label>
            <input type="number" id="simCount" value="100" min="1" max="10000">
          </div>
          <button class="success" onclick="startSimulation()">ğŸš€ å¼€å§‹æ¨¡æ‹Ÿ</button>
          <button onclick="quickSim(10)">10å±€</button>
          <button onclick="quickSim(100)">100å±€</button>
          <button onclick="quickSim(1000)">1000å±€</button>
        </div>

        <div class="progress-bar">
          <div id="simProgress" class="progress-fill" style="width: 0%">0%</div>
        </div>

        <div id="simResults" style="margin-top: 20px;"></div>
      </div>

      <div class="section">
        <h2>ğŸ“‹ æ¨¡æ‹Ÿæ—¥å¿—</h2>
        <div id="simLog" class="log-container">
          <div class="log-entry">ç­‰å¾…å¼€å§‹æ¨¡æ‹Ÿ...</div>
        </div>
      </div>
    </div>

    <!-- æƒé‡ä¼˜åŒ– -->
    <div id="tab-optimizer" class="tab-content">
      <div class="section">
        <h2>âš™ï¸ æƒé‡ä¼˜åŒ–åˆ†æ</h2>
        <div class="control-panel" style="margin-bottom: 15px;">
          <button class="success" onclick="runAnalysis()">ğŸ”¬ è¿è¡Œåˆ†æ</button>
          <button onclick="exportAnalysis()">ğŸ“¤ å¯¼å‡ºåˆ†ææŠ¥å‘Š</button>
        </div>
        <div id="optimizer-content">
          <p style="color: #888; text-align: center; padding: 40px;">ç‚¹å‡»"è¿è¡Œåˆ†æ"æŸ¥çœ‹ä¼˜åŒ–å»ºè®®...</p>
        </div>
      </div>

      <div class="section">
        <h2>ğŸ“‹ å½“å‰æƒé‡é…ç½®</h2>
        <div id="current-weights" class="code-block"></div>
      </div>
    </div>

    <!-- åŸå§‹æ•°æ® -->
    <div id="tab-raw-data" class="tab-content">
      <div class="section">
        <h2>ğŸ“„ åŸå§‹æ¸¸æˆæ•°æ®</h2>
        <div class="control-panel" style="margin-bottom: 15px;">
          <button onclick="loadRawData()">ğŸ”„ åŠ è½½æ•°æ®</button>
          <button onclick="exportData()">ğŸ“¤ å¯¼å‡º JSON</button>
        </div>
        <div id="raw-data-content">
          <p style="color: #888; text-align: center; padding: 40px;">ç‚¹å‡»"åŠ è½½æ•°æ®"æŸ¥çœ‹åŸå§‹æ•°æ®...</p>
        </div>
      </div>
    </div>

    <!-- è°ƒè¯• -->
    <div id="tab-debug" class="tab-content">
      <div class="section">
        <h2>ğŸ” localStorage è¯Šæ–­</h2>
        <div class="control-panel" style="margin-bottom: 15px;">
          <button onclick="loadDebugInfo()">ğŸ”„ åˆ·æ–°è¯Šæ–­</button>
        </div>
        <div id="debug-content"></div>
      </div>
    </div>
  </div>

  <script type="module">
    // ==================== å¯¼å…¥ä¸»ç¨‹åºæ¨¡å— ====================
    // æ³¨æ„ï¼šæ¨¡æ‹Ÿå™¨ç°åœ¨ä½¿ç”¨è‡ªå·±çš„ç®€åŒ–é€»è¾‘ï¼Œä¸å†ä¾èµ– GameRecorder/StatsCollector
    // å®ƒä»¬ä¾èµ– StateManagerï¼Œè€Œæ¨¡æ‹Ÿå™¨æœ‰ç‹¬ç«‹çš„çŠ¶æ€ç®¡ç†
    import { STEMS_LIST, RULES } from './src/js/config/game-config.js';

    // ==================== é…ç½® ====================
    const CONFIG = {
      ELEMENTS: ['æœ¨', 'ç«', 'åœŸ', 'é‡‘', 'æ°´'],
      MAX_TURNS: 60,
      INITIAL_SCORE: 1000,
      // åŠ¨ä½œæ¦‚ç‡ï¼ˆç”¨äºè®¡ç®—ç¨€æœ‰åº¦åŠ æˆï¼‰
      ACTION_PROBABILITY: {
        'AUTO': 1.0,
        'ATK': 0.518,
        'TRANS': 0.243,
        'CONVERT': 0.167,
        'BURST': 0.035,
        'BURST_ATK': 0.036,
      },
      // è¡Œä¸ºåˆ†ï¼ˆæ‰§è¡ŒåŠ¨ä½œçš„åŸºç¡€åˆ†ï¼‰
      ACTION_SCORES: {
        AUTO: 0,
        CONVERT: 50,
        TRANS: 30,
        ATK: 40,
        BURST: 100,
        BURST_ATK: 80
      },
      // çŠ¶æ€åˆ†ï¼ˆçŠ¶æ€å˜åŒ–çš„åˆ†æ•°ï¼‰
      STATE_SCORES: {
        // é˜²å¾¡ç±»ï¼ˆæ­£å‘ï¼‰
        REPAIR_DMG_YANG: 200,  // -1 â†’ 0 ä¿®å¤é“æŸï¼ˆé˜³ï¼‰
        REPAIR_DMG_YIN: 200,   // -1 â†’ 0 ä¿®å¤é“æŸï¼ˆé˜´ï¼‰
        LIGHT_UP: 100,         // 0 â†’ 1 ç‚¹äº®
        BLESSING: 200,         // 1 â†’ 2 åŠ æŒ
        // æ”»å‡»ç±»ï¼ˆè´Ÿå‘ï¼‰
        CAUSE_DMG_YANG: 120,   // 0 â†’ -1 è‡´é“æŸï¼ˆé˜³ï¼‰
        CAUSE_DMG_YIN: 100,    // 0 â†’ -1 è‡´é“æŸï¼ˆé˜´ï¼‰
        BREAK_LIGHT_YANG: 80,  // 1 â†’ 0 ç ´ç‚¹äº®ï¼ˆé˜³ï¼‰
        BREAK_LIGHT_YIN: 60,   // 1 â†’ 0 ç ´ç‚¹äº®ï¼ˆé˜´ï¼‰
        WEAKEN: 80             // 2 â†’ 1 å‰Šå¼±åŠ æŒ
      },
      // å›åˆç»“ç®—
      UNITY_DIVIDEND: 50,      // åŠ æŒåˆ†çº¢ï¼šæ¯ä¸ªå½’ä¸€çŠ¶æ€(2,2)æ¯å›åˆ+50
      DAMAGE_PENALTY: -40,     // é“æŸäºæŸï¼šæ¯ä¸ªé“æŸæ¯å›åˆ-40
      RARITY_MULTIPLIER: 1.5   // ç¨€æœ‰åº¦ä¹˜æ•°
    };

    // ==================== æ¨¡æ‹Ÿå™¨ ====================
    const Simulator = {
      isRunning: false,

      // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
      initGameState() {
        // éšæœºå†³å®šå…ˆæ‰‹ï¼ˆ50/50ï¼‰
        const firstPlayer = Math.random() < 0.5 ? 'P1' : 'P2';
        return {
          turn: 1,
          currentPlayer: firstPlayer,
          phase: 'PLAYING',
          winner: null,
          firstPlayer: firstPlayer, // è®°å½•å…ˆæ‰‹ç©å®¶
          players: {
            P1: { nodes: this.initNodes(), score: CONFIG.INITIAL_SCORE, type: 'AI', burstBonus: true },
            P2: { nodes: this.initNodes(), score: CONFIG.INITIAL_SCORE, type: 'AI', burstBonus: true }
            // burstBonus: true è¡¨ç¤ºå¯ä»¥è§¦å‘BURSTé¢å¤–è¡ŒåŠ¨
            // æ·»åŠ  type: 'AI' ä»¥ä¾¿ä¸»ç¨‹åºé€»è¾‘è¯†åˆ«
            // è¿™ä¸ä¼šè§¦å‘UIæ›´æ–°ï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä½¿ç”¨EventBus
          }
        };
      },

      initNodes() {
        const nodes = [];
        for (let i = 0; i < 5; i++) {
          nodes.push({ yang: 0, yin: 0, element: i });
        }
        return nodes;
      },

      // ç”Ÿæˆéšæœºå¤©å¹²ï¼ˆä¸ä¸»ç¨‹åºä¸€è‡´ï¼Œä» STEMS_LIST éšæœºé€‰æ‹©ï¼‰
      generateStem() {
        const seed = Math.floor(Math.random() * STEMS_LIST.length);
        const stem = STEMS_LIST[seed];
        // å¶æ•°ç´¢å¼•(0,2,4,6,8)æ˜¯é˜³å¹²ï¼Œå¥‡æ•°ç´¢å¼•(1,3,5,7,9)æ˜¯é˜´å¹²
        return {
          element: stem.element,
          name: stem.name,
          yang: seed % 2 === 0
        };
      },

      // è·å–èŠ‚ç‚¹
      getNodes(state, playerId) {
        return state.players[playerId].nodes;
      },

      // æ¨¡æ‹Ÿå•å±€æ¸¸æˆ
      simulateOneGame(debugMode = false) {
        const state = this.initGameState();
        const turns = [];
        const actionCounts = { AUTO: 0, CONVERT: 0, TRANS: 0, ATK: 0, BURST: 0, BURST_ATK: 0 };

        // åˆå§‹åŒ–æ•°æ®æ”¶é›†ï¼ˆä¸ä½¿ç”¨ GameRecorderï¼Œå› ä¸ºå®ƒä¾èµ– StateManagerï¼‰
        const gameData = {
          gameId: 'sim_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9),
          timestamp: Date.now(),
          gameMode: 2, // AI vs AI
          winner: null,
          turnCount: 0,
          finalScores: { P1: 0, P2: 0 },
          stats: {
            actionCounts: { AUTO: 0, CONVERT: 0, TRANS: 0, ATK: 0, BURST: 0, BURST_ATK: 0 },
            unityProgression: [],
            opponentUnityProgression: []
          }
        };

        // è°ƒè¯•ï¼šè®°å½•åˆå§‹çŠ¶æ€
        if (debugMode) {
          console.log('=== æ¸¸æˆå¼€å§‹ ===');
          console.log(`å…ˆæ‰‹: ${state.firstPlayer}`);
          console.log('P1 åˆå§‹çŠ¶æ€:', JSON.parse(JSON.stringify(state.players.P1.nodes)));
          console.log('P2 åˆå§‹çŠ¶æ€:', JSON.parse(JSON.stringify(state.players.P2.nodes)));
        }

        let turnNum = 0;
        while (state.turn <= CONFIG.MAX_TURNS && state.phase === 'PLAYING') {
          // æ ¹æ®å…ˆæ‰‹å†³å®šè¡ŒåŠ¨é¡ºåº
          let currentPlayer = state.firstPlayer;
          const opponentId = currentPlayer === 'P1' ? 'P2' : 'P1';

          // é‡ç½®å½“å‰ç©å®¶çš„ burstBonusï¼ˆæ¯å›åˆå¼€å§‹æ—¶é‡ç½®ï¼‰
          state.players[currentPlayer].burstBonus = true;

          // å…ˆæ‰‹ç©å®¶å›åˆï¼ˆå¯èƒ½å¤šæ¬¡ï¼Œå¦‚æœè§¦å‘BURSTé¢å¤–è¡ŒåŠ¨ï¼‰
          let hasExtraAction = true;
          while (hasExtraAction && state.phase === 'PLAYING') {
            const stem = this.generateStem();
            const action = this.selectAction(state, stem, currentPlayer);

            // å¦‚æœæ²¡æœ‰å¯ç”¨åŠ¨ä½œï¼ˆèŠ‚ç‚¹å·²æ»¡ï¼‰ï¼Œè·³è¿‡è¯¥åŠ¨ä½œ
            if (!action) {
              hasExtraAction = false;
              if (debugMode) {
                console.log(`[è·³è¿‡] ${currentPlayer} èŠ‚ç‚¹å·²æ»¡ï¼Œæ— å¯æ‰§è¡ŒåŠ¨ä½œ`);
              }
              continue;
            }

            this.executeAction(state, action, stem, currentPlayer);
            actionCounts[action.type]++;
            gameData.stats.actionCounts[action.type]++;

            // æ£€æŸ¥æ˜¯å¦è§¦å‘BURSTé¢å¤–è¡ŒåŠ¨
            const isBurstAction = (action.type === 'BURST' || action.type === 'BURST_ATK');
            const hasBurstBonus = state.players[currentPlayer].burstBonus;

            if (isBurstAction && hasBurstBonus) {
              // æ¸…é™¤burstBonusï¼Œå…è®¸å†è¡ŒåŠ¨ä¸€æ¬¡
              state.players[currentPlayer].burstBonus = false;
              hasExtraAction = true;
              if (debugMode) {
                console.log(`[BURSTé¢å¤–è¡ŒåŠ¨] ${currentPlayer} è§¦å‘BURSTé¢å¤–è¡ŒåŠ¨`);
              }
            } else {
              hasExtraAction = false;
            }

            // æ£€æŸ¥èƒœåˆ©
            if (this.checkVictory(state)) break;
          }

          if (state.phase !== 'PLAYING') break;

          const p1Unity = this.evaluateUnity(state.players.P1.nodes);
          const p2Unity = this.evaluateUnity(state.players.P2.nodes);
          gameData.stats.unityProgression.push(p1Unity);
          gameData.stats.opponentUnityProgression.push(p2Unity);

          // è°ƒè¯•ï¼šæ¯10å›åˆè¾“å‡ºä¸€æ¬¡çŠ¶æ€
          if (debugMode && turnNum % 10 === 0) {
            console.log(`[å›åˆ ${turnNum}] P1å½’ä¸€: ${p1Unity}/5, P2å½’ä¸€: ${p2Unity}/5, P1åˆ†æ•°: ${state.players.P1.score}, P2åˆ†æ•°: ${state.players.P2.score}`);
          }

          turnNum++;

          if (this.checkVictory(state)) break;

          // é‡ç½®åæ‰‹ç©å®¶çš„ burstBonusï¼ˆæ¯å›åˆå¼€å§‹æ—¶é‡ç½®ï¼‰
          state.players[opponentId].burstBonus = true;

          // åæ‰‹ç©å®¶å›åˆï¼ˆå¯èƒ½å¤šæ¬¡ï¼Œå¦‚æœè§¦å‘BURSTé¢å¤–è¡ŒåŠ¨ï¼‰
          hasExtraAction = true;
          while (hasExtraAction && state.phase === 'PLAYING') {
            const stem = this.generateStem();
            const action = this.selectAction(state, stem, opponentId);

            // å¦‚æœæ²¡æœ‰å¯ç”¨åŠ¨ä½œï¼ˆèŠ‚ç‚¹å·²æ»¡ï¼‰ï¼Œè·³è¿‡è¯¥åŠ¨ä½œ
            if (!action) {
              hasExtraAction = false;
              if (debugMode) {
                console.log(`[è·³è¿‡] ${opponentId} èŠ‚ç‚¹å·²æ»¡ï¼Œæ— å¯æ‰§è¡ŒåŠ¨ä½œ`);
              }
              continue;
            }

            this.executeAction(state, action, stem, opponentId);
            actionCounts[action.type]++;
            gameData.stats.actionCounts[action.type]++;

            // æ£€æŸ¥æ˜¯å¦è§¦å‘BURSTé¢å¤–è¡ŒåŠ¨
            const isBurstAction = (action.type === 'BURST' || action.type === 'BURST_ATK');
            const hasBurstBonus = state.players[opponentId].burstBonus;

            if (isBurstAction && hasBurstBonus) {
              // æ¸…é™¤burstBonusï¼Œå…è®¸å†è¡ŒåŠ¨ä¸€æ¬¡
              state.players[opponentId].burstBonus = false;
              hasExtraAction = true;
              if (debugMode) {
                console.log(`[BURSTé¢å¤–è¡ŒåŠ¨] ${opponentId} è§¦å‘BURSTé¢å¤–è¡ŒåŠ¨`);
              }
            } else {
              hasExtraAction = false;
            }

            // æ£€æŸ¥èƒœåˆ©
            if (this.checkVictory(state)) break;
          }

          if (state.phase !== 'PLAYING') break;

          const p1Unity2 = this.evaluateUnity(state.players.P1.nodes);
          const p2Unity2 = this.evaluateUnity(state.players.P2.nodes);
          gameData.stats.unityProgression.push(p1Unity2);
          gameData.stats.opponentUnityProgression.push(p2Unity2);
          turnNum++;

          if (this.checkVictory(state)) break;

          // å›åˆç»“ç®—ï¼šåŠ æŒåˆ†çº¢å’Œé“æŸäºæŸ
          this._calculateTurnSettlement(state);

          state.turn++;
        }

        // æ¸¸æˆç»“æŸ
        // state.turn æ˜¯ä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„å›åˆå·ï¼ˆä»1å¼€å§‹ï¼‰ï¼Œæ‰€ä»¥å®é™…å›åˆæ•°æ˜¯ state.turn - 1
        gameData.turnCount = state.turn - 1;
        if (!state.winner) {
          // æŒ‰åˆ†æ•°åˆ¤å®š
          const p1Final = state.players.P1.score;
          const p2Final = state.players.P2.score;
          if (p1Final > p2Final) state.winner = 'P1';
          else if (p2Final > p1Final) state.winner = 'P2';
          else state.winner = 'DRAW';
        }
        gameData.winner = state.winner;
        gameData.finalScores = { P1: state.players.P1.score, P2: state.players.P2.score };

        // è°ƒè¯•ï¼šè¾“å‡ºæ¯å±€æ¸¸æˆç»“æœ
        const p1Unity = this.evaluateUnity(state.players.P1.nodes);
        const p2Unity = this.evaluateUnity(state.players.P2.nodes);
        console.log(`[æ¸¸æˆç»“æŸ] èƒœè€…: ${state.winner}, å›åˆæ•°: ${turnNum}, P1åˆ†æ•°: ${gameData.finalScores.P1}, P2åˆ†æ•°: ${gameData.finalScores.P2}, P1å½’ä¸€: ${p1Unity}, P2å½’ä¸€: ${p2Unity}`);

        // è°ƒè¯•ï¼šæ˜¾ç¤ºæœ€ç»ˆèŠ‚ç‚¹çŠ¶æ€
        if (debugMode) {
          console.log('=== æ¸¸æˆç»“æŸ ===');
          console.log('P1 æœ€ç»ˆçŠ¶æ€:', JSON.parse(JSON.stringify(state.players.P1.nodes)));
          console.log('P2 æœ€ç»ˆçŠ¶æ€:', JSON.parse(JSON.stringify(state.players.P2.nodes)));
          console.log('P1 å½’ä¸€è¿›åº¦:', gameData.stats.unityProgression.slice(-5));
          console.log('P2 å½’ä¸€è¿›åº¦:', gameData.stats.opponentUnityProgression.slice(-5));
        }

        // ä¿å­˜åˆ° localStorage
        this._saveGameData(gameData);

        // è¿”å›æ—¶ä¸åŒ…å« AUTO ç»Ÿè®¡
        const { AUTO, ...playerActions } = actionCounts;
        return {
          winner: state.winner,
          turnCount: turnNum,
          finalScores: { P1: state.players.P1.score, P2: state.players.P2.score },
          actionCounts: playerActions,
          firstPlayer: state.firstPlayer  // æ·»åŠ å…ˆæ‰‹ä¿¡æ¯
        };
      },

      // ä¿å­˜æ¸¸æˆæ•°æ®åˆ° localStorage
      _saveGameData(gameData) {
        try {
          const history = JSON.parse(localStorage.getItem('wuxing_game_history') || '[]');
          history.push(gameData);

          // åªä¿ç•™æœ€è¿‘ 500 å±€
          if (history.length > 500) {
            history.splice(0, history.length - 500);
          }

          localStorage.setItem('wuxing_game_history', JSON.stringify(history));

          // æ›´æ–°ç»Ÿè®¡æ•°æ®ï¼ˆä¸ç»Ÿè®¡ AUTOï¼‰
          const stats = JSON.parse(localStorage.getItem('wuxing_stats_cumulative') || '{"cumulative": {"totalGames": 0, "totalTurns": 0, "p1Wins": 0, "p2Wins": 0, "draws": 0, "actionCounts": {"CONVERT": 0, "TRANS": 0, "ATK": 0, "BURST": 0, "BURST_ATK": 0}}}');
          stats.cumulative.totalGames++;
          stats.cumulative.totalTurns += gameData.turnCount;
          if (gameData.winner === 'P1') stats.cumulative.p1Wins++;
          else if (gameData.winner === 'P2') stats.cumulative.p2Wins++;
          else stats.cumulative.draws++;

          // åªç»Ÿè®¡ç©å®¶ä¸»åŠ¨é€‰æ‹©çš„åŠ¨ä½œï¼Œä¸ç»Ÿè®¡ AUTO
          const { AUTO, ...actionCounts } = gameData.stats.actionCounts;
          for (const action in actionCounts) {
            if (stats.cumulative.actionCounts[action] !== undefined) {
              stats.cumulative.actionCounts[action] += actionCounts[action];
            }
          }

          localStorage.setItem('wuxing_stats_cumulative', JSON.stringify(stats));
        } catch (error) {
          console.error('[Simulator] ä¿å­˜æ•°æ®å¤±è´¥:', error);
        }
      },

      // è¯„ä¼°å½’ä¸€æ•°é‡
      evaluateUnity(nodes) {
        let count = 0;
        for (let i = 0; i < 5; i++) {
          if (nodes[i].yang >= 1 && nodes[i].yin >= 1) count++;
        }
        return count;
      },

      // æ£€æŸ¥èƒœåˆ©
      checkVictory(state) {
        const p1Unity = this.evaluateUnity(state.players.P1.nodes);
        const p2Unity = this.evaluateUnity(state.players.P2.nodes);

        if (p1Unity === 5) {
          state.winner = 'P1';
          state.phase = 'GAME_END';
          return true;
        }
        if (p2Unity === 5) {
          state.winner = 'P2';
          state.phase = 'GAME_END';
          return true;
        }
        return false;
      },

      // é€‰æ‹©åŠ¨ä½œï¼ˆä½¿ç”¨ä¸»ç¨‹åºçš„ ActionValueCalculatorï¼‰
      selectAction(state, stem, playerId) {
        const nodes = this.getNodes(state, playerId);
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';
        const opponentNodes = this.getNodes(state, opponentId);

        // æ£€æŸ¥å¤©å¹²å¯¹åº”çš„èŠ‚ç‚¹çŠ¶æ€ï¼ˆä¸ä¸»ç¨‹åº checkStemLogic ä¸€è‡´ï¼‰
        const nodeState = nodes[stem.element];
        const isYang = (stem.yang !== false);
        const currentState = isYang ? nodeState.yang : nodeState.yin;

        // å¦‚æœ yang<1 æˆ– yin<1ï¼Œè‡ªåŠ¨æ‰§è¡Œ AUTOï¼ˆä¸ä¸»ç¨‹åºä¸€è‡´ï¼‰
        if (currentState < 1) {
          // AUTOï¼šå¤©å¹²é£å…¥å¯¹åº”çš„ä¾§ï¼ˆé˜´æˆ–é˜³ï¼‰
          return {
            type: 'AUTO',
            targetIndex: stem.element,
            element: stem.element,
            isYang: isYang
          };
        }

        // å¦åˆ™ç”Ÿæˆå¯é€‰åŠ¨ä½œ
        const actions = this.generateActions(state, stem, playerId, nodes, opponentNodes);

        if (actions.length === 0) return null;
        if (actions.length === 1) return actions[0];

        // è®¡ç®—æ‰€æœ‰åŠ¨ä½œçš„ä»·å€¼
        const evaluatedActions = actions.map(action => ({
          action,
          value: this.calculateActionValue(state, action, stem, playerId)
        }));

        // æŒ‰ä»·å€¼æ’åº
        evaluatedActions.sort((a, b) => b.value - a.value);

        // å¼•å…¥éšæœºæ€§æ‰“ç ´å¯¹ç§°æ€§ï¼š
        // ä½¿ç”¨è¾ƒå¤§çš„é˜ˆå€¼ï¼Œè®©æ›´å¤šåŠ¨ä½œæœ‰æœºä¼šè¢«é€‰æ‹©
        const threshold = 50; // æ›´å¤§çš„é˜ˆå€¼

        // æ·»åŠ éšæœºæ‰°åŠ¨åˆ°æ¯ä¸ªåŠ¨ä½œçš„ä»·å€¼ï¼ˆçœŸæ­£éšæœºï¼‰
        // ä¸ºäº†ä¿æŒå…¬å¹³ï¼ŒP1å’ŒP2ä½¿ç”¨ç›¸åŒçš„éšæœºé€»è¾‘ï¼Œä½†å„è‡ªç‹¬ç«‹
        const perturbedActions = evaluatedActions.map(ea => {
          // ä½¿ç”¨Math.random()ç”ŸæˆçœŸæ­£çš„éšæœºæ‰°åŠ¨
          // P1å’ŒP2éƒ½ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥éšæœºæ€§æ˜¯å¯¹ç§°çš„
          const perturbation = Math.floor(Math.random() * 41) - 20; // -20 åˆ° +20 çš„éšæœºæ‰°åŠ¨
          return {
            ...ea,
            perturbedValue: ea.value + perturbation
          };
        });

        // æŒ‰æ‰°åŠ¨åçš„ä»·å€¼æ’åº
        perturbedActions.sort((a, b) => b.perturbedValue - a.perturbedValue);

        // æ‰¾å‡ºæ‰€æœ‰ä»·å€¼åœ¨ bestValue - threshold èŒƒå›´å†…çš„åŠ¨ä½œ
        const bestValue = perturbedActions[0].perturbedValue;
        const candidates = perturbedActions.filter(ea => ea.perturbedValue >= bestValue - threshold);

        // ä»å€™é€‰åŠ¨ä½œä¸­éšæœºé€‰æ‹©ä¸€ä¸ª
        const selected = candidates[Math.floor(Math.random() * candidates.length)];

        // è°ƒè¯•ï¼šè¾“å‡ºåŠ¨ä½œé€‰æ‹©
        if (state.turn <= 10) {
          const hasMultipleCandidates = candidates.length > 1;
          if (hasMultipleCandidates || Math.random() < 0.1) {
            console.log(`[Turn ${state.turn}] ${playerId} stem=${stem.name}(${stem.element}) yang=${stem.yang ? 'Y' : 'N'}`);
            console.log(`  å€™é€‰åŠ¨ä½œ: ${candidates.map(c => `${c.action.type}(${c.perturbedValue})`).join(', ')}`);
            console.log(`  é€‰æ‹©: ${selected.action.type}(${selected.perturbedValue})`);
          }
        }

        return selected.action;
      },

      // ç”Ÿæˆå¯ç”¨åŠ¨ä½œï¼ˆåŒ¹é…ä¸»ç¨‹åº ActionCandidates.js çš„é€»è¾‘ï¼‰
      // æ³¨æ„ï¼šAUTO ä¸åœ¨å¯é€‰åŠ¨ä½œåˆ—è¡¨ä¸­ï¼Œå®ƒæ˜¯è‡ªåŠ¨æ‰§è¡Œçš„
      generateActions(state, stem, playerId, nodes, opponentNodes) {
        const actions = [];
        const stemElement = stem.element;
        const isYang = stem.yang !== false;
        const currentNodeState = nodes[stemElement];
        // ä¸ä¸»ç¨‹åºä¸€è‡´ï¼šç²¾ç¡®åŒ¹é… (1,1) å½’ä¸€çŠ¶æ€
        const hasUnity = currentNodeState.yang === 1 && currentNodeState.yin === 1;
        const shengEl = RULES[stemElement].s;
        const keEl = RULES[stemElement].k;
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';

        if (isYang) {
          // é˜³å¹²å¤©å¹²çš„åŠ¨ä½œ
          this._addYangActions(actions, playerId, stemElement, nodes, opponentNodes, hasUnity, shengEl, keEl);
        } else {
          // é˜´å¹²å¤©å¹²çš„åŠ¨ä½œ
          this._addYinActions(actions, playerId, stemElement, nodes, opponentNodes, hasUnity, shengEl, keEl);
        }

        return actions;
      },

      _addYangActions(actions, playerId, stemElement, nodes, opponentNodes, hasUnity, shengEl, keEl) {
        // CONVERT - å¦‚æœé˜´å¹² < 1ï¼Œå¯ä»¥è½¬åˆ°é˜´å¹²
        if (nodes[stemElement].yin < 1) {
          actions.push({
            type: 'CONVERT',
            targetIndex: stemElement,
            element: stemElement,
            isYang: false
          });
        }

        // ATK - æ”»å‡»ç›¸å…‹å±æ€§ï¼ˆå¦‚æœæœ‰ç›®æ ‡ï¼‰
        if (opponentNodes[keEl].yin > -1 || opponentNodes[keEl].yang > -1) {
          actions.push({
            type: 'ATK',
            targetIndex: keEl,
            element: stemElement
          });
        }

        // BURST - å½’ä¸€çŠ¶æ€ä¸‹å¼ºåŒ–ï¼ˆéœ€è¦æ­£å¥½å½’ä¸€çŠ¶æ€ï¼Œä¸”ç›®æ ‡æœªå¡«æ»¡ï¼‰
        if (hasUnity && !(nodes[shengEl].yang === 2 && nodes[shengEl].yin === 2)) {
          actions.push({
            type: 'BURST',
            fromIndex: stemElement,
            toIndex: shengEl
          });
        }

        // BURST_ATK - å½’ä¸€çŠ¶æ€ä¸‹å¼ºç ´
        if (hasUnity && !(opponentNodes[keEl].yang === -1 && opponentNodes[keEl].yin === -1)) {
          actions.push({
            type: 'BURST_ATK',
            targetIndex: keEl,
            element: stemElement
          });
        }
      },

      _addYinActions(actions, playerId, stemElement, nodes, opponentNodes, hasUnity, shengEl, keEl) {
        // CONVERT - å¦‚æœé˜³å¹² < 1ï¼Œå¯ä»¥è½¬åˆ°é˜³å¹²
        if (nodes[stemElement].yang < 1) {
          actions.push({
            type: 'CONVERT',
            targetIndex: stemElement,
            element: stemElement,
            isYang: true
          });
        }

        // TRANS - æµè½¬åˆ°ç”Ÿå±æ€§ï¼ˆå¦‚æœç”Ÿå±æ€§æœªå¡«æ»¡ï¼‰
        if (nodes[shengEl].yin < 2 || nodes[shengEl].yang < 2) {
          actions.push({
            type: 'TRANS',
            fromIndex: stemElement,
            toIndex: shengEl
          });
        }

        // BURST - å½’ä¸€çŠ¶æ€ä¸‹å¼ºåŒ–
        if (hasUnity && !(nodes[shengEl].yang === 2 && nodes[shengEl].yin === 2)) {
          actions.push({
            type: 'BURST',
            fromIndex: stemElement,
            toIndex: shengEl
          });
        }

        // BURST_ATK - å½’ä¸€çŠ¶æ€ä¸‹å¼ºç ´
        if (hasUnity && !(opponentNodes[keEl].yang === -1 && opponentNodes[keEl].yin === -1)) {
          actions.push({
            type: 'BURST_ATK',
            targetIndex: keEl,
            element: stemElement
          });
        }
      },

      // è®¡ç®—å±€åŠ¿åˆ†æ•°ï¼ˆç»¼åˆåˆ¤æ–­ï¼šå½’ä¸€å·®è·70% + åˆ†æ•°å·®è·30%ï¼‰
      _assessSituation(state, playerId) {
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';
        const myUnity = this.evaluateUnity(state.players[playerId].nodes);
        const opponentUnity = this.evaluateUnity(state.players[opponentId].nodes);
        const myScore = state.players[playerId].score;
        const opponentScore = state.players[opponentId].score;

        // å½’ä¸€å·®è·ï¼ˆ-5 åˆ° +5ï¼‰
        const unityDiff = myUnity - opponentUnity;
        // åˆ†æ•°å·®è·å½’ä¸€åŒ–ï¼ˆå¤§çº¦ -30 åˆ° +30ï¼Œé™¤ä»¥100å¾—åˆ°ç±»ä¼¼èŒƒå›´ï¼‰
        const scoreDiff = (myScore - opponentScore) / 100;

        // ç»¼åˆå±€åŠ¿åˆ†æ•°
        return unityDiff * 0.7 + scoreDiff * 0.3;
      },

      // æ ¹æ®å±€åŠ¿è·å–ç³»æ•°
      _getSituationMultipliers(state, playerId) {
        const situationScore = this._assessSituation(state, playerId);

        if (situationScore <= -1) {
          // è½åï¼šæé«˜æ”»å‡»æƒé‡
          return { offense: 1.5, defense: 0.8 };
        } else if (situationScore >= 1) {
          // é¢†å…ˆï¼šæé«˜æ¨è¿›æƒé‡
          return { offense: 0.7, defense: 1.2 };
        } else {
          // æŒå¹³ï¼šæ ‡å‡†æƒé‡
          return { offense: 1.0, defense: 1.0 };
        }
      },

      // è®¡ç®—åŠ¨ä½œä»·å€¼ï¼ˆé‡æ–°è®¾è®¡ï¼šå±€åŠ¿æ„ŸçŸ¥ + ç§»é™¤äººä¸ºå¥–åŠ±ï¼‰
      calculateActionValue(state, action, stem, playerId) {
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';
        const nodes = this.getNodes(state, playerId);
        const opponentNodes = this.getNodes(state, opponentId);

        // è·å–å±€åŠ¿ç³»æ•°
        const multipliers = this._getSituationMultipliers(state, playerId);

        // å½’ä¸€æ¨è¿›åˆ†ï¼ˆé˜²å¾¡ç±»ï¼Œä¹˜ä»¥ defense ç³»æ•°ï¼‰
        const unityScore = this._calculateUnityScore(action, nodes, opponentNodes, stem, playerId) * multipliers.defense;

        // æˆ˜ç•¥åˆ†ï¼ˆæ”»å‡»ç±»ï¼Œä¹˜ä»¥ offense ç³»æ•°ï¼‰
        const strategicScore = this._calculateStrategicScore(action, nodes, opponentNodes, stem, playerId, opponentId) * multipliers.offense;

        return unityScore + strategicScore;
      },

      // è®¡ç®—å½’ä¸€æ¨è¿›åˆ†ï¼ˆé‡æ–°è®¾è®¡ï¼šç§»é™¤äººä¸ºå¥–åŠ±ï¼Œè°ƒæ•´æ•ˆæœåˆ†ï¼‰
      _calculateUnityScore(action, nodes, opponentNodes, stem, playerId) {
        switch (action.type) {
          case 'AUTO':
            // AUTO æ˜¯å…è´¹çš„ä¿®å¤/ç‚¹äº®
            return 70; // ADVANCE_VOID(50) + 20

          case 'CONVERT':
            return this._evaluateConvertAction(action, nodes);

          case 'TRANS':
            return this._evaluateTransAction(action, nodes);

          case 'ATK':
            // ATK çš„ä»·å€¼ä¸»è¦åœ¨æˆ˜ç•¥åˆ†
            return 0;

          case 'BURST':
            return this._evaluateBurstAction(action, nodes, stem);

          case 'BURST_ATK':
            // BURST_ATK çš„ä»·å€¼ä¸»è¦åœ¨æˆ˜ç•¥åˆ†
            return 0;

          default:
            return 50;
        }
      },

      // è¯„ä¼° CONVERT åŠ¨ä½œï¼ˆé‡æ–°è®¾è®¡ï¼‰
      _evaluateConvertAction(action, nodes) {
        const targetIndex = action.targetIndex;
        const node = nodes[targetIndex];

        // åŸºç¡€åˆ†
        const baseScore = 30;

        // CONVERT æ˜¯é˜´é˜³äº’è½¬ï¼Œå¯ä»¥å¿«é€Ÿå®Œæˆå•ä¸€å…ƒç´ çš„å½’ä¸€
        const beforeUnity = node.yang >= 1 && node.yin >= 1;

        // æ¨¡æ‹Ÿæ‰§è¡Œå
        let afterYang = node.yang;
        let afterYin = node.yin;

        // CONVERT çš„ç›®æ ‡ä¾§å¢åŠ  1ï¼ˆæ¨¡æ‹Ÿï¼‰
        if (action.isYang) {
          afterYang = Math.min(afterYang + 1, 2);
        } else {
          afterYin = Math.min(afterYin + 1, 2);
        }

        const afterUnity = afterYang >= 1 && afterYin >= 1;

        // æ•ˆæœåˆ†
        let effectScore = 0;
        if (!beforeUnity && afterUnity) {
          effectScore = 200; // å®Œæˆæ–°å½’ä¸€
        } else if (!afterUnity) {
          effectScore = 100; // æ¥è¿‘å½’ä¸€
        } else if (afterUnity && (afterYang === 2 || afterYin === 2)) {
          effectScore = 60; // å¡«æ»¡åˆä¸€ï¼ˆä»80é™è‡³60ï¼‰
        } else {
          effectScore = 30; // æ™®é€šæ¨è¿›
        }

        return baseScore + effectScore;
      },

      // è¯„ä¼° TRANS åŠ¨ä½œï¼ˆé‡æ–°è®¾è®¡ï¼‰
      _evaluateTransAction(action, nodes) {
        const targetIndex = action.toIndex;
        const node = nodes[targetIndex];

        // åŸºç¡€åˆ†
        const baseScore = 20;

        // TRANS æ˜¯æµè½¬åˆ°ç”Ÿå±æ€§
        // æ£€æŸ¥æ‰§è¡Œåæ˜¯å¦ä¼šæ¨è¿›ç”Ÿå±æ€§
        const beforeUnity = node.yang >= 1 && node.yin >= 1;

        // æ¨¡æ‹Ÿæ‰§è¡Œåï¼ˆTRANS éµå¾ªé˜´å¹²ä¼˜å…ˆè§„åˆ™ï¼‰
        let afterYang = node.yang;
        let afterYin = node.yin;

        if (node.yin < 2) {
          afterYin = Math.min(afterYin + 1, 2);
        } else if (node.yang < 2) {
          afterYang = Math.min(afterYang + 1, 2);
        }

        // å¦‚æœåŠ¨ä½œæ— æ³•æ‰§è¡Œï¼ˆèŠ‚ç‚¹å·²æ»¡ï¼‰ï¼Œè¿”å› 0
        if (afterYang === node.yang && afterYin === node.yin) {
          return 0;
        }

        const afterUnity = afterYang >= 1 && afterYin >= 1;

        // æ•ˆæœåˆ†
        let effectScore = 0;
        if (!beforeUnity && afterUnity) {
          effectScore = 200; // å®Œæˆæ–°å½’ä¸€
        } else {
          effectScore = 100; // æ¥è¿‘å½’ä¸€
        }

        return baseScore + effectScore;
      },

      // è¯„ä¼° BURST åŠ¨ä½œï¼ˆé‡æ–°è®¾è®¡ï¼šç§»é™¤ BURST_BOOSTï¼‰
      _evaluateBurstAction(action, nodes, stem) {
        const stemElement = stem.element;
        const shengElement = RULES[stemElement].s;

        const node = nodes[shengElement];
        const beforeUnity = node.yang >= 1 && node.yin >= 1;

        // åŸºç¡€åˆ†ï¼ˆæ¶ˆè€—é˜´å¹²çš„é£é™©è¡¥å¿ï¼‰
        const baseScore = 80;

        // BURST æ‰§è¡Œä¸¤æ¬¡ï¼Œæ¯æ¬¡éƒ½ä¼šæ¨è¿›
        let effectScore = 0;

        // ç¬¬ä¸€æ¬¡æ¨è¿›
        if (!beforeUnity) {
          effectScore += 100; // æ¥è¿‘å½’ä¸€
        } else {
          effectScore += 60; // å¡«æ»¡åˆä¸€
        }

        // ç¬¬äºŒæ¬¡æ¨è¿›ï¼ˆå›ºå®šå€¼ï¼Œå› ä¸ºç¬¬ä¸€æ¬¡æ¨è¿›åçŠ¶æ€ä¸ç¡®å®šï¼‰
        effectScore += 30; // æ™®é€šæ¨è¿›

        return baseScore + effectScore; // ä¸å†åŠ  BURST_BOOST
      },

      // è®¡ç®—æˆ˜ç•¥åˆ†ï¼ˆä¸ä¸»ç¨‹åºä¸€è‡´ï¼‰
      _calculateStrategicScore(action, nodes, opponentNodes, stem, playerId, opponentId) {
        switch (action.type) {
          case 'ATK':
            return this._evaluateAtkStrategic(action, opponentNodes);

          case 'BURST_ATK':
            return this._evaluateBurstAtkStrategic(action, opponentNodes);

          case 'BURST':
          case 'CONVERT':
          case 'TRANS':
          case 'AUTO':
            return 0;

          default:
            return 0;
        }
      },

      // è¯„ä¼° ATK çš„æˆ˜ç•¥ä»·å€¼ï¼ˆé‡æ–°è®¾è®¡ï¼šé™ä½åŸºç¡€å€¼ï¼‰
      _evaluateAtkStrategic(action, opponentNodes) {
        const targetIndex = action.targetIndex;
        const node = opponentNodes[targetIndex];

        // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å½’ä¸€
        const isUnity = node.yang >= 1 && node.yin >= 1;

        // æ£€æŸ¥ç›®æ ‡æ˜¯å¦åˆä¸€
        const isHarmony = node.yang === 2 && node.yin === 2;

        // ç ´åå¯¹æ–¹å½’ä¸€ï¼ˆ1â†’0ï¼‰- ä» 180 é™è‡³ 150
        if (isUnity && !isHarmony) {
          return 150; // BREAK_OPPOSITE_UNITY
        }

        // ç ´åå¯¹æ–¹åˆä¸€ï¼ˆ2â†’1ï¼‰- ä» 150 é™è‡³ 120
        if (isHarmony) {
          return 120; // BREAK_OPPOSITE_HARMONY
        }

        // é€ æˆé“æŸï¼ˆ0â†’-1ï¼‰- ä» 120 é™è‡³ 100
        return 100; // CAUSE_DAMAGE
      },

      // è¯„ä¼° BURST_ATK çš„æˆ˜ç•¥ä»·å€¼ï¼ˆé‡æ–°è®¾è®¡ï¼šé™ä½åŸºç¡€å€¼ï¼‰
      _evaluateBurstAtkStrategic(action, opponentNodes) {
        const targetIndex = action.targetIndex;
        const node = opponentNodes[targetIndex];

        // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å½’ä¸€
        const isUnity = node.yang >= 1 && node.yin >= 1;

        // æ£€æŸ¥ç›®æ ‡æ˜¯å¦åˆä¸€
        const isHarmony = node.yang === 2 && node.yin === 2;

        // åŒé‡æ‰“å‡»çš„åŸºç¡€åˆ† - ä» 120 é™è‡³ 90
        let score = 90; // BURST_ATK_DOUBLE

        // ç ´åå¯¹æ–¹å½’ä¸€æˆ–åˆä¸€çš„é¢å¤–ä»·å€¼
        if (isHarmony) {
          score += 120; // BREAK_OPPOSITE_HARMONYï¼ˆä»150é™è‡³120ï¼‰
        } else if (isUnity) {
          score += 150; // BREAK_OPPOSITE_UNITYï¼ˆä»180é™è‡³150ï¼‰
        }

        return score;
      },

      evaluateNodes(nodes) {
        let unityCount = 0;
        let harmonyCount = 0;
        let damageCount = 0;
        let nearUnityCount = 0;

        for (let i = 0; i < 5; i++) {
          const node = nodes[i];

          if (node.yang >= 1 && node.yin >= 1) unityCount++;
          if (node.yang === 2 && node.yin === 2) harmonyCount++;
          if (node.yang < 0 || node.yin < 0) damageCount++;
          if ((node.yang >= 1 && node.yin < 1) || (node.yin >= 1 && node.yang < 1)) nearUnityCount++;
        }

        return { unityCount, harmonyCount, damageCount, nearUnityCount };
      },

      simulateAction(nodes, opponentNodes, action, stem, playerId) {
        const scoreChanges = [];
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';

        // è®¡ç®—è¡Œä¸ºåˆ†
        const actionScore = this._getActionScore(action.type);

        switch (action.type) {
          case 'AUTO': {
            const targetIndex = action.targetIndex;
            const beforeState = { ...nodes[targetIndex] };
            // AUTO éœ€è¦çŸ¥é“å¤©å¹²æ˜¯é˜³è¿˜æ˜¯é˜´ï¼Œä» stem æˆ– action.isYang è·å–
            // åœ¨ selectAction ä¸­æˆ‘ä»¬å·²ç»è®¾ç½®äº† action.isYang
            this.simAuto(nodes, targetIndex, action.isYang);
            const afterState = nodes[targetIndex];

            // è®¡ç®—çŠ¶æ€åˆ†ï¼šç¡®å®šå“ªä¸€ä¾§å‘ç”Ÿäº†å˜åŒ–
            const changedSide = action.isYang ?
              (beforeState.yang !== afterState.yang ? 'yang' : 'yin') :
              (beforeState.yin !== afterState.yin ? 'yin' : 'yang');
            const beforeVal = changedSide === 'yang' ? beforeState.yang : beforeState.yin;
            const afterVal = changedSide === 'yang' ? afterState.yang : afterState.yin;
            const stateScore = this._getStateChangeScore(beforeVal, afterVal, action.isYang, false);

            scoreChanges.push({
              playerId,
              actionType: 'AUTO',
              score: actionScore + stateScore
            });
            break;
          }

          case 'CONVERT': {
            const targetIndex = action.targetIndex;
            const beforeState = { ...nodes[targetIndex] };
            this.simConvert(nodes, targetIndex, action.isYang);
            const afterState = nodes[targetIndex];

            // ç¡®å®šæ˜¯é˜³å¹²è¿˜æ˜¯é˜´å¹²å‘ç”Ÿäº†å˜åŒ–
            const isYang = action.isYang;
            const beforeVal = isYang ? beforeState.yang : beforeState.yin;
            const afterVal = isYang ? afterState.yang : afterState.yin;

            // è®¡ç®—çŠ¶æ€åˆ†ï¼ˆå¢åŠ çš„ä¸€æ–¹ï¼‰
            const stateScore = this._getStateChangeScore(beforeVal, afterVal, isYang, false);

            scoreChanges.push({
              playerId,
              actionType: 'CONVERT',
              score: actionScore + stateScore
            });
            break;
          }

          case 'TRANS': {
            const fromIndex = action.fromIndex;
            const toIndex = action.toIndex;

            // æ¥æºèŠ‚ç‚¹å‡å°‘
            const fromBefore = { ...nodes[fromIndex] };
            this.simTrans(nodes, fromIndex, toIndex);
            const fromAfter = nodes[fromIndex];

            // ç›®æ ‡èŠ‚ç‚¹å¢åŠ 
            const toBefore = { ...nodes[toIndex] };
            const toAfter = nodes[toIndex];

            // è®¡ç®—çŠ¶æ€åˆ†ï¼ˆç›®æ ‡èŠ‚ç‚¹ï¼‰
            const toBeforeVal = (toBefore.yin < toBefore.yang) ? toBefore.yin : toBefore.yang;
            const toAfterVal = (toAfter.yin !== toBeforeVal) ? toAfter.yin : toAfter.yang;
            const isYang = (toAfter.yang > toBefore.yang);
            const stateScore = this._getStateChangeScore(toBeforeVal, toAfterVal, isYang, false);

            scoreChanges.push({
              playerId,
              actionType: 'TRANS',
              score: actionScore + stateScore
            });
            break;
          }

          case 'ATK': {
            const targetIndex = action.targetIndex;
            const beforeState = { ...opponentNodes[targetIndex] };
            this.simAtk(opponentNodes, targetIndex);
            const afterState = opponentNodes[targetIndex];

            // ç¡®å®šæ˜¯é˜³å¹²è¿˜æ˜¯é˜´å¹²å‘ç”Ÿäº†å˜åŒ–
            const isYang = (beforeState.yin !== afterState.yin);

            // è®¡ç®—çŠ¶æ€åˆ†
            const beforeVal = isYang ? beforeState.yin : beforeState.yang;
            const afterVal = isYang ? afterState.yin : afterState.yang;
            const stateScore = this._getStateChangeScore(beforeVal, afterVal, isYang, true);

            scoreChanges.push({
              playerId: opponentId,  // æ”»å‡»å¯¹æ–¹ï¼Œå¯¹æ–¹å¾—åˆ†ï¼ˆè´Ÿåˆ†ï¼‰
              actionType: 'ATK',
              score: actionScore + stateScore
            });
            break;
          }

          case 'BURST': {
            const fromIndex = action.fromIndex;
            const toIndex = action.toIndex;

            // æ¶ˆè€—é˜´å¹²
            const fromBefore = { ...nodes[fromIndex] };
            this.simBurst(nodes, fromIndex, toIndex);
            const fromAfter = nodes[fromIndex];

            // å¼ºåŒ–ç›®æ ‡èŠ‚ç‚¹2æ¬¡
            const toBefore = { ...nodes[toIndex] };
            const toAfter = nodes[toIndex];

            // è®¡ç®—çŠ¶æ€åˆ†ï¼ˆæ¥æºèŠ‚ç‚¹æ¶ˆè€—é˜´å¹²ï¼Œç›®æ ‡èŠ‚ç‚¹å¢åŠ ï¼‰
            const fromStateScore = this._getStateChangeScore(fromBefore.yin, fromAfter.yin, false, false);
            const toBeforeVal = (toBefore.yin < toBefore.yang) ? toBefore.yin : toBefore.yang;
            const toAfterVal = (toAfter.yin !== toBeforeVal) ? toAfter.yin : toAfter.yang;
            const toStateScore = this._getStateChangeScore(toBeforeVal, toAfterVal, false, false);

            scoreChanges.push({
              playerId,
              actionType: 'BURST',
              score: actionScore + fromStateScore + toStateScore * 2
            });
            break;
          }

          case 'BURST_ATK': {
            const targetIndex = action.targetIndex;
            const beforeState = { ...opponentNodes[targetIndex] };
            this.simBurstAtk(opponentNodes, targetIndex);
            const afterState = opponentNodes[targetIndex];

            // ç¡®å®šæ˜¯é˜³å¹²è¿˜æ˜¯é˜´å¹²å‘ç”Ÿäº†å˜åŒ–
            const isYang = (beforeState.yin !== afterState.yin);
            const beforeVal = isYang ? beforeState.yin : beforeState.yang;
            const afterVal = isYang ? afterState.yin : afterState.yang;
            const stateScore = this._getStateChangeScore(beforeVal, afterVal, isYang, true);

            scoreChanges.push({
              playerId: opponentId,  // æ”»å‡»å¯¹æ–¹ï¼Œå¯¹æ–¹å¾—åˆ†ï¼ˆè´Ÿåˆ†ï¼‰
              actionType: 'BURST_ATK',
              score: actionScore + stateScore * 2
            });
            break;
          }
        }

        return scoreChanges;
      },

      /**
       * è®¡ç®—å›åˆç»“ç®—ï¼ˆåŠ æŒåˆ†çº¢å’Œé“æŸäºæŸï¼‰
       * @private
       */
      _calculateTurnSettlement(state) {
        // ä¸ºæ¯ä¸ªç©å®¶è®¡ç®—å›åˆç»“ç®—
        for (const playerId of ['P1', 'P2']) {
          let unityCount = 0;    // å½’ä¸€çŠ¶æ€æ•°é‡ (yang=2 ä¸” yin=2)
          let damageCount = 0;   // é“æŸçŠ¶æ€æ•°é‡ (yang=-1 ä¸” yin=-1)

          const nodes = state.players[playerId].nodes;
          for (let i = 0; i < 5; i++) {
            const node = nodes[i];
            // ç»Ÿè®¡å½’ä¸€çŠ¶æ€
            if (node.yang === 2 && node.yin === 2) {
              unityCount++;
            }
            // ç»Ÿè®¡é“æŸçŠ¶æ€
            if (node.yang === -1 && node.yin === -1) {
              damageCount++;
            }
          }

          // å¤©é“åˆ†çº¢ï¼ˆæ­£å‘ï¼‰
          if (unityCount > 0) {
            const points = unityCount * CONFIG.UNITY_DIVIDEND;
            state.players[playerId].score += points;
          }

          // é“æŸäºæŸï¼ˆè´Ÿå‘ï¼‰
          if (damageCount > 0) {
            const penalty = damageCount * CONFIG.DAMAGE_PENALTY;
            state.players[playerId].score += penalty;
          }
        }
      },

      simAuto(nodes, targetIndex, isYang) {
        const node = nodes[targetIndex];
        // AUTO æ ¹æ®å¤©å¹²çš„é˜´é˜³å±æ€§ï¼Œå†³å®šå¢åŠ åˆ°é˜´è¿˜æ˜¯é˜³
        // å¦‚æœç›®æ ‡ä¾§ < 1ï¼Œç›´æ¥è®¾ä¸º 1
        // å¦‚æœç›®æ ‡ä¾§ >= 1ï¼Œä½†å¦ä¸€ä¾§ < 1ï¼Œåˆ™å¢åŠ å¦ä¸€ä¾§
        if (isYang) {
          // é˜³å¹²å¤©å¹²ï¼Œä¼˜å…ˆå¢åŠ é˜³å¹²
          if (node.yang < 1) {
            node.yang = 1;
          } else if (node.yin < 1) {
            node.yin = 1;
          } else if (node.yang < 2) {
            node.yang++;
          } else {
            node.yin++;
          }
        } else {
          // é˜´å¹²å¤©å¹²ï¼Œä¼˜å…ˆå¢åŠ é˜´å¹²
          if (node.yin < 1) {
            node.yin = 1;
          } else if (node.yang < 1) {
            node.yang = 1;
          } else if (node.yin < 2) {
            node.yin++;
          } else {
            node.yang++;
          }
        }
      },

      simConvert(nodes, targetIndex, isYang) {
        const node = nodes[targetIndex];
        // CONVERT æ˜¯å°†ä¸€ä¾§è½¬ç§»åˆ°å¦ä¸€ä¾§
        // å¦‚æœ isYang=trueï¼Œåˆ™é˜³å¹²å¢åŠ ï¼Œé˜´å¹²å‡å°‘
        // å¦‚æœ isYang=falseï¼Œåˆ™é˜´å¹²å¢åŠ ï¼Œé˜³å¹²å‡å°‘
        if (isYang) {
          if (node.yin > 0) node.yin--;
          else if (node.yang < 2) node.yang++;
        } else {
          if (node.yang > 0) node.yang--;
          else if (node.yin < 2) node.yin++;
        }
      },

      simTrans(nodes, fromIndex, toIndex) {
        const fromNode = nodes[fromIndex];
        const toNode = nodes[toIndex];

        // å‡å°‘æ¥æºèŠ‚ç‚¹ï¼šé˜´å¹²ä¼˜å…ˆï¼ˆé˜´å¹²>0å°±å‡é˜´å¹²ï¼Œå¦åˆ™å‡é˜³å¹²ï¼‰
        if (fromNode.yin > 0) fromNode.yin--;
        else if (fromNode.yang > 0) fromNode.yang--;

        // å¢åŠ ç›®æ ‡èŠ‚ç‚¹ï¼šé˜´å¹²ä¼˜å…ˆï¼ˆé˜´å¹²<2å°±å¢åŠ é˜´å¹²ï¼Œå¦åˆ™å¢åŠ é˜³å¹²ï¼‰
        // ä¸ä¸»ç¨‹åº ActionResolver.applyPlus ä¸€è‡´
        if (toNode.yin < 2) toNode.yin++;
        else if (toNode.yang < 2) toNode.yang++;
      },

      simAtk(opponentNodes, targetIndex) {
        const node = opponentNodes[targetIndex];
        // å‡å°‘å¯¹æ–¹èŠ‚ç‚¹ï¼šé˜´å¹²ä¼˜å…ˆï¼ˆé˜´å¹²>-1å°±å‡é˜´å¹²ï¼Œå¦åˆ™å‡é˜³å¹²ï¼‰
        // ä¸ä¸»ç¨‹åº ActionResolver.applyMinus ä¸€è‡´
        if (node.yin > -1) node.yin--;
        else if (node.yang > -1) node.yang--;
      },

      simBurst(nodes, fromIndex, toIndex) {
        const fromNode = nodes[fromIndex];
        const toNode = nodes[toIndex];

        // ç¬¬1æ­¥ï¼šæ¶ˆè€—è‡ªèº«æœ¬å‘½çš„é˜´ï¼ˆåˆä¸€çŠ¶æ€ï¼‰
        // åªæœ‰å½“é˜´å¹²>0æ—¶æ‰èƒ½æ¶ˆè€—ï¼ˆä¸ä¸»ç¨‹åº applyMinus ä¸€è‡´ï¼‰
        if (fromNode.yin <= 0) return; // æ— æ³•æ‰§è¡Œ
        fromNode.yin--;

        // ç¬¬2-3æ­¥ï¼šå¼ºåŒ–è‡ªèº«ç”Ÿå±æ€§2æ¬¡
        // ä¸ä¸»ç¨‹åº applyPlus ä¸€è‡´ï¼šæŒ‰é˜´å¹²ä¼˜å…ˆè§„åˆ™ï¼Œæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å·²æ»¡
        for (let i = 0; i < 2; i++) {
          // é˜´å¹²ä¼˜å…ˆï¼šå¦‚æœé˜´å¹²<2ï¼Œå¢åŠ é˜´å¹²
          if (toNode.yin < 2) {
            toNode.yin++;
          }
          // é˜´å¹²=2æ—¶ï¼Œè½¬å‘é˜³å¹²
          else if (toNode.yang < 2) {
            toNode.yang++;
          }
          // ä¸¤è€…éƒ½å·²æ»¡ï¼ŒBURST æ— æ³•ç»§ç»­ï¼ˆä¸ä¸»ç¨‹åº applyPlus è¿”å› false ä¸€è‡´ï¼‰
          else {
            break; // èŠ‚ç‚¹å·²æ»¡ï¼Œåœæ­¢å¼ºåŒ–
          }
        }
      },

      simBurstAtk(opponentNodes, targetIndex) {
        const node = opponentNodes[targetIndex];

        // æ”»å‡»å¯¹æ–¹å…‹å±æ€§2æ¬¡
        // ä¸ä¸»ç¨‹åº applyMinus ä¸€è‡´ï¼šé˜´å¹²ä¼˜å…ˆï¼Œæ£€æŸ¥é“æŸçŠ¶æ€
        for (let i = 0; i < 2; i++) {
          // ä¼˜å…ˆé˜´å¹²ï¼šå¦‚æœé˜´å¹²>-1ï¼Œå‡å°‘é˜´å¹²
          if (node.yin > -1) {
            node.yin--;
          }
          // é˜´å¹²é“æŸæ—¶ï¼Œè½¬å‘é˜³å¹²
          else if (node.yang > -1) {
            node.yang--;
          }
          // ä¸¤è€…éƒ½æ˜¯é“æŸï¼Œæ— æ³•ç»§ç»­æ”»å‡»ï¼ˆä¸ä¸»ç¨‹åº applyMinus è¿”å› false ä¸€è‡´ï¼‰
          else {
            break; // èŠ‚ç‚¹å·²å®Œå…¨é“æŸï¼Œåœæ­¢æ”»å‡»
          }
        }
      },

      executeAction(state, action, stem, playerId) {
        const nodes = this.getNodes(state, playerId);
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';
        const opponentNodes = this.getNodes(state, opponentId);

        // è®°å½•çŠ¶æ€å˜åŒ–ä»¥è®¡ç®—åˆ†æ•°
        const scoreChanges = this.simulateAction(nodes, opponentNodes, action, stem, playerId);

        // åº”ç”¨åˆ†æ•°
        for (const change of scoreChanges) {
          const finalScore = this._applyRarityBonus(change.score, change.actionType);
          state.players[change.playerId].score += finalScore;
        }
      },

      /**
       * è®¡ç®—åŠ¨ä½œåˆ†æ•°
       * @returns {number} åˆ†æ•°
       */
      _getActionScore(actionType) {
        return CONFIG.ACTION_SCORES[actionType] || 0;
      },

      /**
       * è®¡ç®—çŠ¶æ€å˜åŒ–åˆ†æ•°
       * @returns {number} åˆ†æ•°
       */
      _getStateChangeScore(beforeState, afterState, isYang, isAttack) {
        // æ”»å‡»ç±»çŠ¶æ€å˜åŒ–
        if (isAttack) {
          if (beforeState === 0 && afterState === -1) {
            return isYang ? CONFIG.STATE_SCORES.CAUSE_DMG_YANG : CONFIG.STATE_SCORES.CAUSE_DMG_YIN;
          }
          if (beforeState === 1 && afterState === 0) {
            return isYang ? CONFIG.STATE_SCORES.BREAK_LIGHT_YANG : CONFIG.STATE_SCORES.BREAK_LIGHT_YIN;
          }
          if (beforeState === 2 && afterState === 1) {
            return CONFIG.STATE_SCORES.WEAKEN;
          }
        } else {
          // é˜²å¾¡ç±»çŠ¶æ€å˜åŒ–
          if (beforeState === -1 && afterState === 0) {
            return isYang ? CONFIG.STATE_SCORES.REPAIR_DMG_YANG : CONFIG.STATE_SCORES.REPAIR_DMG_YIN;
          }
          if (beforeState === 0 && afterState === 1) {
            return CONFIG.STATE_SCORES.LIGHT_UP;
          }
          if (beforeState === 1 && afterState === 2) {
            return CONFIG.STATE_SCORES.BLESSING;
          }
        }
        return 0;
      },

      /**
       * åº”ç”¨ç¨€æœ‰åº¦åŠ æˆ
       * @returns {number} æœ€ç»ˆåˆ†æ•°
       */
      _applyRarityBonus(score, actionType) {
        const prob = CONFIG.ACTION_PROBABILITY[actionType] || 0.5;
        const rarityBonus = score * (1 - prob) * CONFIG.RARITY_MULTIPLIER;
        return Math.round(score + rarityBonus);
      },

      // æ‰¹é‡æ¨¡æ‹Ÿ
      async simulateBatch(count, onProgress) {
        const results = [];

        for (let i = 0; i < count; i++) {
          const result = this.simulateOneGame();
          results.push(result);

          if (onProgress && (i + 1) % 10 === 0) {
            onProgress(i + 1, count);
            // è®©UIæœ‰æœºä¼šæ›´æ–°
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        return results;
      }
    };

    // ==================== ç»Ÿè®¡åˆ†æ ====================
    function analyzeResults(results) {
      let p1Wins = 0, p2Wins = 0, draws = 0;
      let totalTurns = 0;
      const actionCounts = { AUTO: 0, CONVERT: 0, TRANS: 0, ATK: 0, BURST: 0, BURST_ATK: 0 };

      results.forEach(game => {
        if (game.winner === 'P1') p1Wins++;
        else if (game.winner === 'P2') p2Wins++;
        else draws++;

        totalTurns += game.turnCount;

        if (game.actionCounts) {
          for (const action in actionCounts) {
            actionCounts[action] += game.actionCounts[action] || 0;
          }
        }
      });

      return {
        totalGames: results.length,
        p1Wins,
        p2Wins,
        draws,
        p1WinRate: (p1Wins / results.length * 100).toFixed(1) + '%',
        avgTurns: (totalTurns / results.length).toFixed(1),
        actionCounts
      };
    }

    // ==================== UI å‡½æ•° ====================
    window.startSimulation = async function() {
      if (Simulator.isRunning) {
        addSimLog('æ¨¡æ‹Ÿæ­£åœ¨è¿›è¡Œä¸­...', 'warning');
        return;
      }

      const count = parseInt(document.getElementById('simCount').value);
      Simulator.isRunning = true;
      addSimLog('å¼€å§‹æ¨¡æ‹Ÿ ' + count + ' å±€...', 'info');

      try {
        const startTime = Date.now();
        const results = await Simulator.simulateBatch(count, (current, total) => {
          const progress = (current / total * 100).toFixed(1);
          document.getElementById('simProgress').style.width = progress + '%';
          document.getElementById('simProgress').textContent = progress + '%';
        });

        const elapsed = Date.now() - startTime;
        const stats = analyzeResults(results);

        displaySimResults(stats, elapsed);
        addSimLog('æ¨¡æ‹Ÿå®Œæˆï¼ç”¨æ—¶ ' + (elapsed / 1000).toFixed(2) + ' ç§’', 'success');

        Simulator.isRunning = false;
      } catch (error) {
        addSimLog('æ¨¡æ‹Ÿå‡ºé”™: ' + error.message, 'error');
        console.error(error);
        Simulator.isRunning = false;
      }
    };

    window.quickSim = function(count) {
      document.getElementById('simCount').value = count;
      window.startSimulation();
    };

    function displaySimResults(stats, elapsed) {
      const html = `
        <div class="stats-grid">
          <div class="stat-card"><div class="label">æ€»å±€æ•°</div><div class="value">${stats.totalGames}</div></div>
          <div class="stat-card"><div class="label">P1èƒœç‡</div><div class="value">${stats.p1WinRate}</div></div>
          <div class="stat-card"><div class="label">P2èƒœç‡</div><div class="value">${stats.p2WinRate || '0%'}</div></div>
          <div class="stat-card"><div class="label">å¹³å‡å›åˆ</div><div class="value">${stats.avgTurns}</div></div>
          <div class="stat-card"><div class="label">ç”¨æ—¶</div><div class="value">${(elapsed / 1000).toFixed(2)}s</div></div>
        </div>

        <div class="section" style="margin-top: 15px;">
          <h3 style="color: #2dcc70; margin-bottom: 10px;">ğŸ® åŠ¨ä½œä½¿ç”¨ç»Ÿè®¡ï¼ˆä¸å« AUTOï¼‰</h3>
          <div class="action-stats">
            ${Object.entries(stats.actionCounts).map(([action, count]) => {
              // è®¡ç®—æ¯å±€å¹³å‡ä½¿ç”¨æ¬¡æ•°
              const avgPerGame = (count / stats.totalGames).toFixed(2);
              return `<div class="action-item">
                <span class="action-name">${getActionName(action)}</span>
                <span class="action-count">${count}æ¬¡</span>
                <span class="action-percentage">${avgPerGame}æ¬¡/å±€</span>
              </div>`;
            }).join('')}
          </div>
        </div>
      `;
      document.getElementById('simResults').innerHTML = html;
    }

    function addSimLog(message, type = '') {
      const logContainer = document.getElementById('simLog');
      const time = new Date().toLocaleTimeString('zh-CN');
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = '[' + time + '] ' + message;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // ==================== å…¶ä»–æ ‡ç­¾é¡µ ====================
    window.switchTab = function(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById('tab-' + tabName).classList.add('active');

      if (tabName === 'overview') loadOverview();
      if (tabName === 'raw-data') loadRawData();
      if (tabName === 'debug') loadDebugInfo();
      if (tabName === 'optimizer') loadCurrentWeights();
    };

    window.loadOverview = function() {
      const historyData = localStorage.getItem('wuxing_game_history');
      const statsData = localStorage.getItem('wuxing_stats_cumulative');

      if (!historyData && !statsData) {
        document.getElementById('overview-content').innerHTML = '<p style="color: #888; text-align: center; padding: 40px;">æš‚æ— æ•°æ®</p>';
        return;
      }

      const history = historyData ? JSON.parse(historyData) : [];
      const stats = statsData ? JSON.parse(statsData) : { cumulative: { totalGames: 0, totalTurns: 0 } };

      let html = '<div class="stats-grid">';
      html += '<div class="stat-card"><div class="label">æ€»å±€æ•°</div><div class="value">' + stats.cumulative.totalGames + '</div></div>';
      html += '<div class="stat-card"><div class="label">å¹³å‡å›åˆ</div><div class="value">' + (stats.cumulative.totalTurns / Math.max(stats.cumulative.totalGames, 1)).toFixed(1) + '</div></div>';
      html += '<div class="stat-card"><div class="label">P1èƒœç‡</div><div class="value">' + getWinRate(stats, 'P1') + '</div></div>';
      html += '<div class="stat-card"><div class="label">P2èƒœç‡</div><div class="value">' + getWinRate(stats, 'P2') + '</div></div>';
      html += '</div>';

      html += '<div class="section" style="margin-top: 15px;"><h2>ğŸ® åŠ¨ä½œä½¿ç”¨ç»Ÿè®¡</h2>';
      const actionStats = getActionStats(stats);
      html += '<div class="action-stats">';
      for (const action in actionStats.byAction) {
        const item = actionStats.byAction[action];
        html += '<div class="action-item">';
        html += '<span class="action-name">' + getActionName(action) + '</span>';
        html += '<span class="action-count">' + item.count + 'æ¬¡</span>';
        html += '<span class="action-percentage">' + item.percentage + '</span>';
        html += '</div>';
      }
      html += '</div></div>';

      document.getElementById('overview-content').innerHTML = html;
    };

    function getWinRate(stats, player) {
      const total = stats.cumulative.totalGames;
      if (total === 0) return '0%';
      const wins = player === 'P1' ? stats.cumulative.p1Wins : stats.cumulative.p2Wins;
      return (wins / total * 100).toFixed(1) + '%';
    }

    window.getActionName = function(action) {
      const names = {
        'AUTO': 'è‡ªåŠ¨å¸çº³',
        'CONVERT': 'è°ƒæ¯',
        'TRANS': 'åŒ–',
        'ATK': 'ç ´',
        'BURST': 'å¼ºåŒ–',
        'BURST_ATK': 'å¼ºç ´'
      };
      return names[action] || action;
    };

    function getActionStats(stats) {
      const byAction = {};
      // å…ˆè®¡ç®—æ€»æ•°
      let total = 0;
      for (const action in stats.cumulative.actionCounts) {
        total += stats.cumulative.actionCounts[action];
      }
      // å†è®¡ç®—æ¯ä¸ªåŠ¨ä½œçš„ç™¾åˆ†æ¯”
      for (const action in stats.cumulative.actionCounts) {
        byAction[action] = {
          count: stats.cumulative.actionCounts[action],
          percentage: total > 0 ? (stats.cumulative.actionCounts[action] / total * 100).toFixed(1) + '%' : '0%'
        };
      }
      return { total, byAction };
    }

    window.clearAllData = function() {
      if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
        localStorage.removeItem('wuxing_game_history');
        localStorage.removeItem('wuxing_stats_cumulative');
        loadOverview();
        addSimLog('å·²æ¸…é™¤æ‰€æœ‰æ•°æ®', 'warning');
      }
    };

    window.exportData = function() {
      const historyData = localStorage.getItem('wuxing_game_history');
      const statsData = localStorage.getItem('wuxing_stats_cumulative');

      const data = {
        history: historyData ? JSON.parse(historyData) : [],
        stats: statsData ? JSON.parse(statsData) : null,
        exportTime: new Date().toISOString()
      };

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ai_data_' + new Date().getTime() + '.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    window.loadRawData = function() {
      const historyData = localStorage.getItem('wuxing_game_history');

      if (!historyData) {
        document.getElementById('raw-data-content').innerHTML = '<p style="color: #888; text-align: center; padding: 40px;">æš‚æ— æ•°æ®</p>';
        return;
      }

      const history = JSON.parse(historyData);
      document.getElementById('raw-data-content').innerHTML = '<div class="code-block">' + JSON.stringify(history, null, 2) + '</div>';
    };

    window.loadDebugInfo = function() {
      let html = '';

      html += '<div class="info-box" style="margin-bottom: 15px;">';
      html += '<h3>å½“å‰é¡µé¢ä¿¡æ¯</h3>';
      html += '<p><strong>URL:</strong> ' + window.location.href + '</p>';
      html += '<p><strong>Origin:</strong> ' + window.location.origin + '</p>';
      html += '</div>';

      const allKeys = Object.keys(localStorage);
      if (allKeys.length === 0) {
        html += '<p style="color: #888;">localStorage ä¸ºç©º</p>';
      } else {
        html += '<div class="stats-grid">';
        html += '<div class="stat-card"><div class="label">æ€»é”®æ•°</div><div class="value">' + allKeys.length + '</div></div>';

        const hasHistory = localStorage.getItem('wuxing_game_history');
        const hasStats = localStorage.getItem('wuxing_stats_cumulative');
        html += '<div class="stat-card"><div class="label">æ¸¸æˆå†å²</div><div class="value" style="color: ' + (hasHistory ? '#2dcc70' : '#ff6b6b') + '">' + (hasHistory ? 'âœ“' : 'âœ—') + '</div></div>';
        html += '<div class="stat-card"><div class="label">ç»Ÿè®¡æ•°æ®</div><div class="value" style="color: ' + (hasStats ? '#2dcc70' : '#ff6b6b') + '">' + (hasStats ? 'âœ“' : 'âœ—') + '</div></div>';
        html += '</div>';

        html += '<h4 style="margin: 15px 0 10px 0; color: #888;">æ‰€æœ‰é”®åˆ—è¡¨:</h4>';
        html += '<div class="code-block">';
        allKeys.forEach(key => {
          const value = localStorage.getItem(key);
          const preview = value.length > 100 ? value.substring(0, 100) + '...' : value;
          html += '<div><strong>' + key + '</strong>: ' + preview + '</div>';
        });
        html += '</div>';
      }

      document.getElementById('debug-content').innerHTML = html;
    };

    window.loadCurrentWeights = function() {
      const weights = {
        // å±€åŠ¿ç³»æ•°
        SITUATION_MULTIPLIERS: {
          BEHIND: { offense: 1.5, defense: 0.8 },    // è½åæ—¶
          EVEN: { offense: 1.0, defense: 1.0 },      // æŒå¹³æ—¶
          AHEAD: { offense: 0.7, defense: 1.2 }      // é¢†å…ˆæ—¶
        },
        // åŸºç¡€åˆ†
        BASE_SCORES: {
          CONVERT: 30,
          TRANS: 20,
          BURST: 80,
          ATK: 0,
          BURST_ATK: 0
        },
        // æ•ˆæœåˆ†ï¼ˆå½’ä¸€æ¨è¿›ï¼‰
        UNITY_PROGRESSION: {
          COMPLETE_NEW: 200,     // å®Œæˆæ–°å½’ä¸€
          CLOSE_TO_UNITY: 100,   // æ¥è¿‘å½’ä¸€
          FILL_HARMONY: 60,      // å¡«æ»¡åˆä¸€ï¼ˆä»80é™è‡³60ï¼‰
          NORMAL_PROGRESS: 30    // æ™®é€šæ¨è¿›
        },
        // æˆ˜ç•¥åˆ†ï¼ˆæ”»å‡»ç ´åï¼‰
        STRATEGIC: {
          BREAK_OPPOSITE_UNITY: 150,    // ç ´åå¯¹æ–¹å½’ä¸€ï¼ˆä»180é™è‡³150ï¼‰
          BREAK_OPPOSITE_HARMONY: 120,  // ç ´åå¯¹æ–¹åˆä¸€ï¼ˆä»150é™è‡³120ï¼‰
          CAUSE_DAMAGE: 100,            // é€ æˆé“æŸï¼ˆä»120é™è‡³100ï¼‰
          BURST_ATK_DOUBLE: 90          // BURST_ATKåŸºç¡€ï¼ˆä»120é™è‡³90ï¼‰
        },
        // å±€åŠ¿åˆ¤æ–­æƒé‡
        SITUATION_WEIGHTS: {
          UNITY: 0.7,        // å½’ä¸€å·®è·æƒé‡
          SCORE: 0.3         // åˆ†æ•°å·®è·æƒé‡
        }
      };

      document.getElementById('current-weights').textContent = JSON.stringify(weights, null, 2);
    };

    window.runAnalysis = function() {
      const historyData = localStorage.getItem('wuxing_game_history');

      if (!historyData) {
        document.getElementById('optimizer-content').innerHTML = '<p style="color: #888; text-align: center; padding: 40px;">æš‚æ— æ•°æ®å¯åˆ†æ</p>';
        return;
      }

      const history = JSON.parse(historyData);
      const suggestions = analyzeData(history);

      let html = '<div class="stats-grid">';
      html += '<div class="stat-card"><div class="label">åˆ†æå±€æ•°</div><div class="value">' + history.length + '</div></div>';
      html += '<div class="stat-card"><div class="label">å»ºè®®æ•°é‡</div><div class="value">' + suggestions.length + '</div></div>';
      html += '</div>';

      if (suggestions.length === 0) {
        html += '<p style="color: #2dcc70; text-align: center; padding: 40px;">âœ“ AI è¡¨ç°è‰¯å¥½ï¼Œæš‚æ— ä¼˜åŒ–å»ºè®®</p>';
      } else {
        suggestions.forEach(s => {
          html += '<div class="suggestion-item' + (s.severity === 'error' ? ' error' : '') + '">';
          html += '<h4>' + s.type + '</h4>';
          html += '<p>' + s.message + '</p>';
          html += '<p style="color: #888; font-size: 12px; margin-top: 5px;">å»ºè®®: ' + s.action + '</p>';
          html += '</div>';
        });
      }

      document.getElementById('optimizer-content').innerHTML = html;
    };

    function analyzeData(history) {
      const suggestions = [];
      const actionCounts = { AUTO: 0, CONVERT: 0, TRANS: 0, ATK: 0, BURST: 0, BURST_ATK: 0 };
      let totalActions = 0;

      history.forEach(game => {
        if (game.stats && game.stats.actionCounts) {
          for (const action in game.stats.actionCounts) {
            actionCounts[action] += game.stats.actionCounts[action];
            totalActions += game.stats.actionCounts[action];
          }
        }
      });

      // æ£€æŸ¥åŠ¨ä½œä½¿ç”¨è¿‡å°‘
      for (const action in actionCounts) {
        if (actionCounts[action] / totalActions < 0.05 && totalActions > 100) {
          suggestions.push({
            type: 'åŠ¨ä½œä½¿ç”¨åˆ†æ',
            severity: 'warning',
            message: getActionName(action) + ' ä½¿ç”¨ç‡è¿‡ä½ (' + (actionCounts[action] / totalActions * 100).toFixed(1) + '%)',
            action: 'å¯èƒ½éœ€è¦è°ƒæ•´è¯¥åŠ¨ä½œçš„æƒé‡æˆ–æ£€æŸ¥è§¦å‘æ¡ä»¶'
          });
        }
      }

      // æ£€æŸ¥ BURST ä½¿ç”¨
      if (actionCounts.BURST === 0 && history.length > 50) {
        suggestions.push({
          type: 'BURST åˆ†æ',
          severity: 'warning',
          message: 'BURST ä»æœªè¢«ä½¿ç”¨',
          action: 'åˆä¸€çŠ¶æ€(2,2)è¾¾æˆç‡å¯èƒ½è¿‡ä½ï¼Œæˆ– BURST æƒé‡ä¸å¤Ÿé«˜'
        });
      }

      // åˆ†æèƒœç‡
      let p1Wins = 0;
      history.forEach(game => {
        if (game.winner === 'P1') p1Wins++;
      });
      const p1WinRate = p1Wins / history.length;

      if (p1WinRate < 0.4 && history.length > 50) {
        suggestions.push({
          type: 'èƒœç‡åˆ†æ',
          severity: 'error',
          message: 'P1 èƒœç‡åä½ (' + (p1WinRate * 100).toFixed(1) + '%)',
          action: 'å»ºè®®æ£€æŸ¥ AI å†³ç­–é€»è¾‘æˆ–è°ƒæ•´å½’ä¸€æ¨è¿›æƒé‡'
        });
      } else if (p1WinRate > 0.6) {
        suggestions.push({
          type: 'èƒœç‡åˆ†æ',
          severity: '',
          message: 'P1 èƒœç‡è¾ƒé«˜ (' + (p1WinRate * 100).toFixed(1) + '%)',
          action: 'AI è¡¨ç°è‰¯å¥½ï¼Œå¯ä»¥è€ƒè™‘å¢åŠ éš¾åº¦æˆ–æµ‹è¯•å¤šæ ·åŒ–ç­–ç•¥'
        });
      }

      // åˆ†æå¹³å‡å›åˆæ•°
      let totalTurns = 0;
      history.forEach(game => {
        totalTurns += game.turnCount;
      });
      const avgTurns = totalTurns / history.length;

      if (avgTurns > 50 && history.length > 20) {
        suggestions.push({
          type: 'å›åˆæ•°åˆ†æ',
          severity: 'warning',
          message: 'å¹³å‡å›åˆæ•°åé«˜ (' + avgTurns.toFixed(1) + ')',
          action: 'å¯èƒ½éœ€è¦æé«˜è¿›æ”»æ€§ï¼Œå‡å°‘é˜²å®ˆç­–ç•¥'
        });
      }

      return suggestions;
    }

    window.exportAnalysis = function() {
      const historyData = localStorage.getItem('wuxing_game_history');
      if (!historyData) {
        alert('æš‚æ— æ•°æ®å¯å¯¼å‡º');
        return;
      }

      const history = JSON.parse(historyData);
      const analysis = {
        totalGames: history.length,
        timestamp: new Date().toISOString(),
        suggestions: analyzeData(history),
        actionStats: getActionStats(JSON.parse(localStorage.getItem('wuxing_stats_cumulative') || '{}'))
      };

      const blob = new Blob([JSON.stringify(analysis, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ai_analysis_' + new Date().getTime() + '.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    // åˆå§‹åŒ–
    loadOverview();
    loadCurrentWeights();
    addSimLog('æ¨¡æ‹Ÿå™¨å·²å°±ç»ªï¼ˆä½¿ç”¨ä¸»ç¨‹åºé€»è¾‘ï¼‰', 'success');

    // ==================== è°ƒè¯•å‡½æ•°ï¼ˆæ§åˆ¶å°ä½¿ç”¨ï¼‰ ====================
    // åœ¨æµè§ˆå™¨æ§åˆ¶å°è¾“å…¥ debugOneGame() æ¥è¿è¡Œä¸€å±€è¯¦ç»†è°ƒè¯•çš„æ¸¸æˆ
    window.debugOneGame = function() {
      console.log('=== å¼€å§‹è°ƒè¯•æ¸¸æˆ ===');
      const result = Simulator.simulateOneGame(true);
      console.log('=== æ¸¸æˆç»“æœ ===', result);
      return result;
    };

    // åœ¨æ§åˆ¶å°è¾“å…¥ debugManyGames(n) æ¥è¿è¡Œnå±€æ¸¸æˆ
    window.debugManyGames = function(count = 10) {
      console.log(`=== å¼€å§‹è°ƒè¯• ${count} å±€æ¸¸æˆ ===`);
      const results = [];
      let firstPlayerWins = { P1: 0, P2: 0 };

      for (let i = 0; i < count; i++) {
        const result = Simulator.simulateOneGame(i === 0); // åªåœ¨ç¬¬ä¸€å±€æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—
        results.push(result);

        // ç»Ÿè®¡å…ˆæ‰‹ç©å®¶èƒœç‡
        if (result.winner !== 'DRAW') {
          const firstPlayer = result.firstPlayer || 'P1';
          if (result.winner === firstPlayer) {
            firstPlayerWins[firstPlayer]++;
          }
        }
      }

      const p1Wins = results.filter(r => r.winner === 'P1').length;
      const p2Wins = results.filter(r => r.winner === 'P2').length;
      const draws = results.filter(r => r.winner === 'DRAW').length;

      console.log(`=== è°ƒè¯•å®Œæˆ ===`);
      console.log(`P1èƒœ: ${p1Wins}, P2èƒœ: ${p2Wins}, å¹³å±€: ${draws}`);
      console.log(`P1èƒœç‡: ${(p1Wins / count * 100).toFixed(1)}%, P2èƒœç‡: ${(p2Wins / count * 100).toFixed(1)}%`);
      console.log(`å…ˆæ‰‹ç©å®¶èƒœç‡ç»Ÿè®¡: P1å…ˆæ‰‹æ—¶P1èƒœ ${firstPlayerWins.P1}, P2å…ˆæ‰‹æ—¶P2èƒœ ${firstPlayerWins.P2}`);

      return { p1Wins, p2Wins, draws, results, firstPlayerWins };
    };

    // åœ¨æ§åˆ¶å°è¾“å…¥ traceActions() è¿½è¸ªå‰10å›åˆçš„åŠ¨ä½œç”Ÿæˆå’Œé€‰æ‹©
    window.traceActions = function() {
      console.log('=== è¿½è¸ªåŠ¨ä½œç”Ÿæˆå’Œé€‰æ‹© ===');
      const actionStats = { CONVERT: 0, TRANS: 0, ATK: 0, BURST: 0, BURST_ATK: 0, AUTO: 0 };
      const selectionDetails = [];

      // ä¸´æ—¶ä¿å­˜åŸå§‹çš„ selectAction æ–¹æ³•
      const originalSelectAction = Simulator.selectAction.bind(Simulator);

      // é‡å†™ selectAction æ¥è®°å½•è¯¦ç»†ä¿¡æ¯
      Simulator.selectAction = function(state, stem, playerId) {
        const nodes = this.getNodes(state, playerId);
        const opponentId = playerId === 'P1' ? 'P2' : 'P1';
        const opponentNodes = this.getNodes(state, opponentId);

        // æ£€æŸ¥æ˜¯å¦ä¸º AUTO
        const nodeState = nodes[stem.element];
        const isYang = (stem.yang !== false);
        const currentState = isYang ? nodeState.yang : nodeState.yin;

        if (currentState < 1) {
          actionStats.AUTO++;
          if (state.turn <= 10) {
            console.log(`[Turn ${state.turn}] ${playerId} ${stem.name}(${stem.element}) -> AUTO (state=${currentState})`);
          }
          return originalSelectAction(state, stem, playerId);
        }

        // ç”ŸæˆåŠ¨ä½œ
        const actions = this.generateActions(state, stem, playerId, nodes, opponentNodes);

        if (actions.length === 0) return null;
        if (actions.length === 1) {
          actionStats[actions[0].type]++;
          if (state.turn <= 10) {
            console.log(`[Turn ${state.turn}] ${playerId} ${stem.name}(${stem.element}) -> ${actions[0].type} (only action)`);
          }
          return actions[0];
        }

        // è®¡ç®—æ‰€æœ‰åŠ¨ä½œçš„ä»·å€¼
        const evaluatedActions = actions.map(action => ({
          action,
          value: this.calculateActionValue(state, action, stem, playerId)
        }));

        // æ·»åŠ éšæœºæ‰°åŠ¨
        const perturbedActions = evaluatedActions.map(ea => ({
          ...ea,
          perturbedValue: ea.value + Math.floor(Math.random() * 41) - 20
        }));

        // æ‰¾å‡ºå€™é€‰åŠ¨ä½œ
        perturbedActions.sort((a, b) => b.perturbedValue - a.perturbedValue);
        const bestValue = perturbedActions[0].perturbedValue;
        const candidates = perturbedActions.filter(ea => ea.perturbedValue >= bestValue - 50);
        const selected = candidates[Math.floor(Math.random() * candidates.length)];

        actionStats[selected.action.type]++;

        if (state.turn <= 10) {
          const actionList = evaluatedActions.map(ea =>
            `${ea.action.type}(${ea.value})`
          ).join(', ');
          console.log(`[Turn ${state.turn}] ${playerId} ${stem.name}(${stem.element})`);
          console.log(`  å¯ç”¨åŠ¨ä½œ: ${actionList}`);
          console.log(`  æ‰°åŠ¨å: ${perturbedActions.map(pa =>
            `${pa.action.type}(${pa.perturbedValue})`
          ).join(', ')}`);
          console.log(`  å€™é€‰: ${candidates.map(c => `${c.action.type}(${c.perturbedValue})`).join(', ')}`);
          console.log(`  é€‰æ‹©: ${selected.action.type}(${selected.perturbedValue})`);
        }

        selectionDetails.push({
          turn: state.turn,
          playerId,
          stem: stem.name,
          actions: actions.map(a => a.type),
          values: evaluatedActions.map(ea => ({ type: ea.action.type, value: ea.value })),
          selected: selected.action.type
        });

        return selected.action;
      };

      // è¿è¡Œä¸€å±€æ¸¸æˆ
      const result = Simulator.simulateOneGame(false);

      // æ¢å¤åŸå§‹æ–¹æ³•
      Simulator.selectAction = originalSelectAction;

      console.log('=== åŠ¨ä½œç»Ÿè®¡ ===');
      console.log(actionStats);
      console.log('=== æ€»åŠ¨ä½œæ•°ï¼ˆä¸å«AUTOï¼‰ ===');
      const totalWithoutAuto = Object.entries(actionStats)
        .filter(([k]) => k !== 'AUTO')
        .reduce((sum, [, v]) => sum + v, 0);
      console.log(totalWithoutAuto);
      console.log('=== åŠ¨ä½œåˆ†å¸ƒï¼ˆä¸å«AUTOï¼‰ ===');
      for (const [action, count] of Object.entries(actionStats)) {
        if (action !== 'AUTO' && count > 0) {
          console.log(`${action}: ${count} (${(count / totalWithoutAuto * 100).toFixed(1)}%)`);
        }
      }

      return { actionStats, selectionDetails, result };
    };

    // æ¸…é™¤ç´¯ç§¯ç»Ÿè®¡æ•°æ® - é‡æ–°å¼€å§‹ç»Ÿè®¡
    window.clearStats = function() {
      console.log('=== æ¸…é™¤ç´¯ç§¯ç»Ÿè®¡æ•°æ® ===');
      localStorage.removeItem('wuxing_stats_cumulative');
      localStorage.removeItem('wuxing_game_history');
      console.log('å·²æ¸…é™¤ã€‚è¯·åˆ·æ–°é¡µé¢æˆ–é‡æ–°è¿è¡Œæ¨¡æ‹Ÿã€‚');
    };

    // è¯Šæ–­å‡½æ•°ï¼šæŸ¥çœ‹åŠ¨ä½œç”Ÿæˆæƒ…å†µ
    window.diagnoseActions = function() {
      console.log('=== è¯Šæ–­åŠ¨ä½œç”Ÿæˆ ===');
      const generationStats = {
        totalStems: 0,
        yangStems: 0,
        yinStems: 0,
        autoTriggered: 0,
        playerChoice: 0,
        actionsGenerated: {
          CONVERT: 0,
          TRANS: 0,
          ATK: 0,
          BURST: 0,
          BURST_ATK: 0
        }
      };

      const originalSelectAction = Simulator.selectAction.bind(Simulator);

      Simulator.selectAction = function(state, stem, playerId) {
        const nodes = this.getNodes(state, playerId);
        const nodeState = nodes[stem.element];
        const isYang = (stem.yang !== false);
        const currentState = isYang ? nodeState.yang : nodeState.yin;

        generationStats.totalStems++;
        if (isYang) generationStats.yangStems++;
        else generationStats.yinStems++;

        if (currentState < 1) {
          generationStats.autoTriggered++;
          return originalSelectAction(state, stem, playerId);
        }

        generationStats.playerChoice++;

        const opponentId = playerId === 'P1' ? 'P2' : 'P1';
        const opponentNodes = this.getNodes(state, opponentId);
        const actions = this.generateActions(state, stem, playerId, nodes, opponentNodes);

        if (state.turn <= 20) {
          console.log(`[Turn ${state.turn}] ${playerId} ${stem.name}(${stem.element}) ${isYang ? 'é˜³' : 'é˜´'}`);
          console.log(`  èŠ‚ç‚¹çŠ¶æ€: yang=${nodeState.yang}, yin=${nodeState.yin}`);
          console.log(`  ç”ŸæˆåŠ¨ä½œ: ${actions.map(a => a.type).join(', ') || 'æ— '}`);
        }

        for (const action of actions) {
          if (generationStats.actionsGenerated[action.type] !== undefined) {
            generationStats.actionsGenerated[action.type]++;
          }
        }

        return originalSelectAction(state, stem, playerId);
      };

      Simulator.simulateOneGame(false);

      Simulator.selectAction = originalSelectAction;

      console.log('=== å¤©å¹²ç»Ÿè®¡ ===');
      console.log(`æ€»å¤©å¹²æ•°: ${generationStats.totalStems}`);
      console.log(`é˜³å¹²: ${generationStats.yangStems} (${(generationStats.yangStems/generationStats.totalStems*100).toFixed(1)}%)`);
      console.log(`é˜´å¹²: ${generationStats.yinStems} (${(generationStats.yinStems/generationStats.totalStems*100).toFixed(1)}%)`);
      console.log(`AUTOè§¦å‘: ${generationStats.autoTriggered} (${(generationStats.autoTriggered/generationStats.totalStems*100).toFixed(1)}%)`);
      console.log(`ç©å®¶é€‰æ‹©: ${generationStats.playerChoice} (${(generationStats.playerChoice/generationStats.totalStems*100).toFixed(1)}%)`);

      console.log('=== åŠ¨ä½œç”Ÿæˆç»Ÿè®¡ ===');
      for (const [action, count] of Object.entries(generationStats.actionsGenerated)) {
        console.log(`${action}: ${count} æ¬¡`);
      }

      return generationStats;
    };
  </script>
</body>
</html>
